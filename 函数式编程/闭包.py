# 闭包工作流程：调用闭包外函数-->返回闭包内函数及用到的外函数数据-->调用内函数--->内函数和外函数数据进行运算--->返回结果
# 内函数可以多次调用，但里面包含的外函数数据是相同的！！！ 当做出修改后，对后面的内函数调用都起作用

# 个人觉得，闭包 就是可以在一个函数(内层函数)上多附加一些参数。 只不过这个参数是另一个函数（外层函数）所产生的


# 作用域是程序运行时变量可被访问的范围，定义在函数内的变量是局部变量，局部变量的作用范围只能是函数内部范围内，它不能在函数外引用。

# 定义在模块最外层的变量是全局变量，它是全局范围内可见的，当然在函数里面也可以读取到全局变量的。
# 但不能修改，如果函数内想要修改全局变量，则要进行global声明

num = 10 # 全局作用域变量
def foo():
    print(num)  # 10

# 而在函数外部则不可以访问局部变量(函数内部的)。

def foo1():
    num1 = 10
print(num1)  # NameError: name 'num' is not defined


# 对于嵌套函数，它可以访问到其外层作用域中声明的非局部（non-local）变量，比如代码示例中的变量 msg 可以被嵌套函数 printer 正常访问。
# 但也不能修改，如果要修改，再要进行 Nonlocal 声明，或者使用list----传递的是一个指向常量地址集合的地址，所以函数内修改了，外部也会变化
def print_msg():
    # print_msg 是外围函数
    msg = "zen of python"

    def printer():
        # printer是嵌套函数
        print(msg)
    printer()
# 输出 zen of python
print_msg()

# 那么有没有一种可能即使脱离了函数本身的作用范围，局部变量还可以被访问得到呢？答案是闭包
# 一般情况下，函数中的局部变量仅在函数的执行期间可用，一旦 print_msg() 执行过后，我们会认为 msg变量将不再可用。
# 然而，在这里我们发现 print_msg 执行完之后，在调用 another 的时候 msg 变量的值正常输出了，这就是闭包的作用，
# 闭包使得局部变量在函数外被访问成为可能。
def print_msg1():
    # print_msg1 是外围函数
    msg = "zen of python"
    def printer():
        # printer 是嵌套函数
        print(msg)
    return printer

another = print_msg1()
# 输出 zen of python
another()

# 在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。
# 这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。
# 所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。

# 这里的 another 就是一个闭包，闭包本质上是一个函数，它由两部分组成，printer 函数和变量 msg。闭包使得这些变量的值始终保存在内存中。

# 闭包，顾名思义，就是一个封闭的包裹，里面包裹着自由变量，就像在类里面定义的属性值一样，自由变量的可见范围随同包裹一起，
# 哪里可以访问到这个包裹，哪里就可以访问到这个自由变量。

# 为什么要使用闭包
# 闭包避免了使用全局变量，此外，闭包允许将函数与其所操作的某些数据（环境）关连起来。
# 这一点与面向对象编程是非常类似的，在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。

def adder(x):
    def wrapper(y):
        return x + y
    return wrapper

adder5 = adder(5)
# 输出 15
adder5(10)
# 输出 11
adder5(6)

#修改闭包变量的实例
 2 # outer是外部函数 a和b都是外函数的临时变量
 3 def outer( a ):
 4     b = 10  # a和b都是闭包变量
 5     c = [a] #这里对应修改闭包变量的方法2
 6     # inner是内函数
 7     def inner():
 8         #内函数中想修改闭包变量
 9         # 方法1 nonlocal关键字声明
10         nonlocal  b
11         b+=1
12         # 方法二，把闭包变量修改成可变数据类型 比如列表
13         c[0] += 1
14         print(c[0])
15         print(b)
16     # 外函数的返回值是内函数的引用
17     return inner
18 
19 if __name__ == '__main__':
20 
21     demo = outer(5)
22 demo()  # 6  11


# 使用闭包的过程中，一旦外函数被调用一次返回了内函数的引用，虽然每次调用内函数，是开启一个函数执行过后消亡，
# 但是闭包变量实际上只有一份，每次开启内函数都在使用同一份闭包变量
def outer(x):
 3     def inner(y):
 4         nonlocal x
 5         x+=y
 6         return x
 7     return inner
 8 
 9 
10 a = outer(10)
11 print(a(1)) #//11
12 print(a(3))  #//14 ，因为第一次调用a(1)时，里面的 x 值是10，然后被改为11。 当第二次a(3)调用时，x值就是11,所以结果是14。

# 闭包的最大特点是可以将父函数的变量与内部函数绑定，并返回绑定变量后的函数（也即闭包），此时即便生成闭包的环境（父函数）已经释放，
# 闭包仍然存在，这个过程很像类（父函数）生成实例（闭包），不同的是父函数只在调用时执行，执行完毕后其环境就会释放，
# 而类则在文件执行时创建，一般程序执行完毕后作用域才释放，因此对一些需要重用的功能且不足以定义为类的行为，
# 使用闭包会比使用类占用更少的资源，且更轻巧灵活